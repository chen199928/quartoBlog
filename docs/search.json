[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/probability-theory/index.html",
    "href": "posts/probability-theory/index.html",
    "title": "Probability theory and random variables",
    "section": "",
    "text": "1. Use Case: Email spam detection\nThe goal of this blog is to develop a detection system and data visualization for email spams.Each email‚Äôs text in the dataset can be considered as a random variable. We will use The Naive Bayers model and probablity theory to analyze the probablity that an email is spam given the text in that email. The process involves training the Naive Bayes model using a provided dataset, enabling the model to learn and make predictions on new, unseen data. ### 2. Import the libraries:\n\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.naive_bayes import MultinomialNB\nfrom sklearn.metrics import roc_curve, auc\nimport matplotlib.pyplot as plt\n\n\n\n3. Display the dataset\nBelow is the code to load ‚Äúemails.csv‚Äù file into the pandas dataframe.\n\nemail_df = pd.read_csv(\"emails.csv\")\nemail_df['category'] = email_df['spam'].replace({1: 'spam', 0: 'not spam'})\nemail_df\n\n\n\n\n\n\n\n\ntext\nspam\ncategory\n\n\n\n\n0\nSubject: naturally irresistible your corporate...\n1\nspam\n\n\n1\nSubject: the stock trading gunslinger fanny i...\n1\nspam\n\n\n2\nSubject: unbelievable new homes made easy im ...\n1\nspam\n\n\n3\nSubject: 4 color printing special request add...\n1\nspam\n\n\n4\nSubject: do not have money , get software cds ...\n1\nspam\n\n\n...\n...\n...\n...\n\n\n5723\nSubject: re : research and development charges...\n0\nnot spam\n\n\n5724\nSubject: re : receipts from visit jim , than...\n0\nnot spam\n\n\n5725\nSubject: re : enron case study update wow ! a...\n0\nnot spam\n\n\n5726\nSubject: re : interest david , please , call...\n0\nnot spam\n\n\n5727\nSubject: news : aurora 5 . 2 update aurora ve...\n0\nnot spam\n\n\n\n\n5728 rows √ó 3 columns\n\n\n\n\n\n4. groupby based on category column (‚Äúspam‚Äù‚Äù and ‚Äúnot spam‚Äù)\ngroupby will group the spam and not spam in the category column, and it will provide us with detailed analysis of the groups spam and not spam.\n\nemail_df.groupby('category').describe()\n\n\n\n\n\n\n\n\nspam\n\n\n\ncount\nmean\nstd\nmin\n25%\n50%\n75%\nmax\n\n\ncategory\n\n\n\n\n\n\n\n\n\n\n\n\nnot spam\n4360.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\nspam\n1368.0\n1.0\n0.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\n\n\n\n\n\n\n\n5. use scikit-learn to split data into training set:\nTo evaluate the model, train_test_split is used to split spam email dataset into training and testing sets. In this case, 20% of the data will be used for tesing, and 80% of the data will be used for training. Additionally, CountVectorizer is applied to convert the text data into a matrix of words counts, and fit_transform is used to fit the vectorizer to the training data and build the model.\n\nx_train, x_test, y_train, y_test = train_test_split(email_df.text, email_df.spam, test_size=0.20)\ncv = CountVectorizer()\nx_train_count = cv.fit_transform(x_train.values)\nx_train_count.toarray()\n\narray([[0, 0, 0, ..., 0, 0, 0],\n       [1, 0, 0, ..., 0, 0, 0],\n       [0, 0, 0, ..., 0, 0, 0],\n       ...,\n       [0, 0, 0, ..., 0, 0, 0],\n       [0, 0, 0, ..., 0, 0, 0],\n       [0, 1, 0, ..., 0, 0, 0]])\n\n\n\n\n6. create a Multinomial Bayes model:\nIt will train the model, which enables it to make predictions on new data.\n\n#train model\nmodel = MultinomialNB()\nmodel.fit(x_train_count, y_train)\n\nMultinomialNB()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.MultinomialNBMultinomialNB()\n\n\n\n\n7. Below is the examples of spam and non-spam emails:\n\nexample 1:\n\nemail_ham = [\"Please come prepared with any updates or materials you'd like to share with the team.\"]\nemail_ham_count = cv.transform(email_ham)\nmodel.predict(email_ham_count)\n\narray([0])\n\n\nThe message in the example 1 is not a spam email, and it appears to be the team communication in a business context. The training model also gives a value of 0 which means it predicts that it is not a spam email.\n\n\nexample 2:\n\n# pre-test spam\nemail_spam = [\"ou are the lucky winner of our exclusive giveaway! ü•≥ You've won a brand new iPhone 12 and a $500 shopping voucher!\"]\nemail_spam_count = cv.transform(email_spam)\nmodel.predict(email_spam_count)\n\narray([1])\n\n\nThe message in the example 2 is a spam email, and it appears to be one of the tricks to promote their products. The training model also gives a value of 1 which means it predicts that it is a spam email.\n\n\n\n8. Prediction accuracy:\nBelow shows the accuracy of the model on the test data.\n\nx_test_count = cv.transform(x_test)\nmodel.score(x_test_count, y_test)\n\n0.9947643979057592\n\n\n\n\n9. ROC curve to evaluate the performance of our email spam detection system:\nThe ROC curve is used to understand and visualize the performance of our email spam detection system. To interpret ROC curve, the closer the ROC curve to the true postive rate axis, the better the model‚Äôs performance.\n\ny_prob = model.predict_proba(x_test_count)[:, 1]\n\n# Compute the ROC curve\nfpr, tpr, thresholds = roc_curve(y_test, y_prob)\n\nroc_auc = auc(fpr, tpr)\nplt.figure()\nplt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc)\nplt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')\nplt.xlim([0.0, 1.0])\nplt.ylim([0.0, 1.0])\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\nplt.title('Receiver Operating Characteristic')\nplt.legend(loc=\"lower right\")\nplt.show()"
  },
  {
    "objectID": "posts/anomaly-outlier-detection/index.html",
    "href": "posts/anomaly-outlier-detection/index.html",
    "title": "Anomaly/outlier detection",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "posts/classification/index.html",
    "href": "posts/classification/index.html",
    "title": "Classification",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "posts/clustering/index.html",
    "href": "posts/clustering/index.html",
    "title": "Clustering",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "posts/regression/index.html",
    "href": "posts/regression/index.html",
    "title": "Linear and nonlinear regression",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn‚Äôt specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "quartoBlog",
    "section": "",
    "text": "Classification\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nNov 20, 2023\n\n\nYouwei Chen\n\n\n\n\n\n\n  \n\n\n\n\nClustering\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nNov 20, 2023\n\n\nYouwei Chen\n\n\n\n\n\n\n  \n\n\n\n\nLinear and nonlinear regression\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nNov 20, 2023\n\n\nYouwei Chen\n\n\n\n\n\n\n  \n\n\n\n\nProbability theory and random variables\n\n\n\n\n\n\n\nmachine learning\n\n\npython\n\n\ndata visualization\n\n\n\n\n\n\n\n\n\n\n\nNov 20, 2023\n\n\nYouwei Chen\n\n\n\n\n\n\n  \n\n\n\n\nAnomaly/outlier detection\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nSep 12, 2023\n\n\nYouwei Chen\n\n\n\n\n\n\nNo matching items"
  }
]